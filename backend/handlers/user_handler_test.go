package handlers_test

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/monteirobsb/user-management/backend/database"
	"github.com/monteirobsb/user-management/backend/handlers"
	"github.com/monteirobsb/user-management/backend/models"
	"github.com/stretchr/testify/assert"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

func setupRouterAndTestDB(t *testing.T) *gin.Engine {
	gin.SetMode(gin.TestMode)
	db, err := gorm.Open(sqlite.Open("file::memory:"), &gorm.Config{})
	if err != nil {
		t.Fatalf("Failed to connect to test database: %v", err)
	}

	err = db.AutoMigrate(&models.User{})
	if err != nil {
		t.Fatalf("Failed to migrate test database schema: %v", err)
	}
	database.DB = db

	router := gin.New()
	userRoutes := router.Group("/api/users")
	{
		userRoutes.POST("", handlers.CreateUserHandler)
		userRoutes.PUT("/:id", handlers.UpdateUserHandler)
	}
	return router
}

func performRequest(router *gin.Engine, method, path string, body interface{}) *httptest.ResponseRecorder {
	var reqBody *bytes.Buffer
	if body != nil {
		payloadBytes, _ := json.Marshal(body)
		reqBody = bytes.NewBuffer(payloadBytes)
	} else {
		reqBody = bytes.NewBuffer(make([]byte, 0))
	}
	req, _ := http.NewRequest(method, path, reqBody)
	req.Header.Set("Content-Type", "application/json")
	w := httptest.NewRecorder()
	router.ServeHTTP(w, req)
	return w
}

func TestCreateUserHandler_ValidationAndSuccess(t *testing.T) {
	assert := assert.New(t)
	testCases := []struct {
		name         string
		payload      interface{}
		expectedCode int
		bodyContains string
		dbCheck      func(t *testing.T, email string)
	}{
		{
			name: "Valid Data",
			payload: models.UserCreateRequest{Name: "Test User", Email: "valid." + uuid.NewString() + "@example.com", Password: "password123"},
			expectedCode: http.StatusCreated,
			bodyContains: `"email":"valid.`,
			dbCheck: func(t *testing.T, email string) {
				var user models.User
				err := database.DB.Where("email = ?", email).First(&user).Error
				assert.NoError(err, "User should be created in DB")
				assert.Equal("Test User", user.Name)
			},
		},
		{name: "Missing Name", payload: models.UserCreateRequest{Email: "noname@example.com", Password: "password123"}, expectedCode: http.StatusBadRequest, bodyContains: "Name"},
		{name: "Invalid Email", payload: models.UserCreateRequest{Name: "Test User", Email: "invalid-email", Password: "password123"}, expectedCode: http.StatusBadRequest, bodyContains: "Email"},
		{name: "Missing Password", payload: models.UserCreateRequest{Name: "Test User", Email: "nopass@example.com"}, expectedCode: http.StatusBadRequest, bodyContains: "Password"},
		{name: "Short Password", payload: models.UserCreateRequest{Name: "Test User", Email: "shortpass@example.com", Password: "pass"}, expectedCode: http.StatusBadRequest, bodyContains: "Password"},
	}

	for _, tc := range testCases {
		router := setupRouterAndTestDB(t) // Fresh DB for each create test case
		t.Run(tc.name, func(t *testing.T) {
			w := performRequest(router, "POST", "/api/users", tc.payload)
			assert.Equal(tc.expectedCode, w.Code, "Expected HTTP status code for "+tc.name)
			if tc.bodyContains != "" {
				assert.Contains(w.Body.String(), tc.bodyContains, "Response body for "+tc.name)
			}
			if tc.dbCheck != nil {
				email := ""
				if req, ok := tc.payload.(models.UserCreateRequest); ok { email = req.Email }
				tc.dbCheck(t, email)
			}
		})
	}
}

func TestUpdateUserHandler_ValidationAndSuccess(t *testing.T) {
	assert := assert.New(t)
	router := setupRouterAndTestDB(t) // Single DB instance for this set of update tests

	initialUserName := "Initial User"
	initialUserEmail := "initial.update." + uuid.NewString() + "@example.com"

	createdUser := models.User{ // ID will be auto-generated by BeforeCreate hook
		Name:         initialUserName,
		Email:        initialUserEmail,
		PasswordHash: "dummyhash", // Not testing password update here
	}
	err := database.DB.Create(&createdUser).Error // GORM populates createdUser.ID
	assert.NoError(err, "Setup: Failed to create initial user for update tests")
	assert.NotEmpty(createdUser.ID, "Setup: createdUser.ID should be populated by GORM")

	actualTestUserIDString := createdUser.ID.String()

	testCases := []struct {
		name         string
		userID       string
		payload      interface{}
		expectedCode int
		bodyContains string
		dbCheck      func(t *testing.T, id uuid.UUID)
	}{
		{
			name:   "Valid Update Data (Name only)",
			userID: actualTestUserIDString,
			payload: models.UserUpdateRequest{Name: func(s string) *string { return &s }("Updated Name")},
			expectedCode: http.StatusOK,
			bodyContains: `"name":"Updated Name"`,
			dbCheck: func(t *testing.T, id uuid.UUID) {
				var user models.User
				errDb := database.DB.First(&user, "id = ?", id).Error
				assert.NoError(errDb, "DBCheck: User should be found post-update")
				assert.Equal("Updated Name", user.Name, "DBCheck: Name should be updated")
				assert.Equal(initialUserEmail, user.Email, "DBCheck: Email should remain unchanged")
			},
		},
		{
			name:   "Valid Update Data (Email only)",
			userID: actualTestUserIDString,
			payload: models.UserUpdateRequest{Email: func(s string) *string { return &s }("updated." + uuid.NewString() + "@example.com")},
			expectedCode: http.StatusOK,
			bodyContains: `"email":"updated.`,
			dbCheck: func(t *testing.T, id uuid.UUID) {
				var user models.User
				errDb := database.DB.First(&user, "id = ?", id).Error
				assert.NoError(errDb, "DBCheck: User should be found post-update")
				assert.Equal("Updated Name", user.Name, "DBCheck: Name should be from previous update") // Assumes state from previous sub-test
				assert.Contains(user.Email, "updated.", "DBCheck: Email should be updated")
			},
		},
		{
			name:   "Empty Name String",
			userID: actualTestUserIDString,
			payload: models.UserUpdateRequest{Name: func(s string) *string { return &s }("")},
			expectedCode: http.StatusBadRequest,
			bodyContains: "Name",
		},
		{
			name:   "Invalid Email Format",
			userID: actualTestUserIDString,
			payload: models.UserUpdateRequest{Email: func(s string) *string { return &s }("invalid-email")},
			expectedCode: http.StatusBadRequest,
			bodyContains: "Email",
		},
		{
			name:         "Invalid User ID in Path (non-UUID)",
			userID:       "invalid-uuid-format",
			payload:      models.UserUpdateRequest{},
			expectedCode: http.StatusBadRequest,
			bodyContains: "ID de usuário inválido",
		},
		{
			name:         "User ID not found (valid UUID, but no user)",
			userID:       uuid.New().String(),
			payload:      models.UserUpdateRequest{Name: func(s string) *string { return &s }("Any Name")},
			expectedCode: http.StatusNotFound,
			bodyContains: "Usuário não encontrado",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			w := performRequest(router, "PUT", "/api/users/"+tc.userID, tc.payload)
			assert.Equal(tc.expectedCode, w.Code, "Expected HTTP status code for "+tc.name)
			if tc.bodyContains != "" {
				assert.Contains(w.Body.String(), tc.bodyContains, "Response body for "+tc.name)
			}
			if tc.dbCheck != nil && tc.expectedCode == http.StatusOK {
				parsedID, _ := uuid.Parse(tc.userID)
				tc.dbCheck(t, parsedID)
			}
		})
	}
}
